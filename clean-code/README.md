# Чистый код. Роберт Мартин

## Глава 1. Чистый код

1. Беспорядок в коде замедляет работу с ним.

2. Программист несет ответственность за донесение до начальства реальных сроков разработки,
  которые учитывают написание правильного чистого кода.

3. Программисты больше читают код, чем пишут его. Чтение старого кода необходимо для написания нового. Поэтому чистота
  кода является очень важным пунктом.

4. Правило бойскаута: оставлять код чище, чем он был до нашего прихода.

## Глава 2. Содержательные имена

1. Имена должны передавать намерения программиста.

2. Не использовать в названии переменной тип данных или структуру данных, в которой хранятся данные.
  Это может вводить в заблуждение и вызывать ненужные ассоциации. Структура данных может поменяться в дальнейшем.

3. Записывать различающиеся имена так, чтобы читатель кода понимал, какой смысл заложен в этих различиях. Например,
  `Product` и `ProductInfo`, `money` и `moneyAmount` - плохие отличия в именах.

4. Имена должны удобно читаться как обычные слова.

5. Использовать для перегрузок конструкторов статические методы-фабрики. Соответствующие конструкторы
  можно объявлять приватными. Например:

```java
// Bad
new Complex(23.0)

// Good
Complex.FromRealNumber(23.0)
```

6. Использовать одно слово для представления одной абстрактной концепции или сущности. Например, `get`, `fetch`,
  `retreive` называются по-разному, но в сущности выполняют одно и то же действие, и по названиям не понятно,
  в чем их отличия, если они есть. Но если методы выполняют семантически разные вещи, то и названия должны отличаться.

7. Добавлять именам содержательный контекст. Например, если несколько переменных являются частью какой-то сущности,
  то их следует объединить в объект или пространство имен. Так будет понятен их контекст.

8. Не добавлять именам избыточный контекст. Например, нет смысла добавлять префикс класса ко всем полям этого класса -
  они и так уже находятся в его контексте. Именам классов так же не следует давать дополнительный контекст, если они
  потенциально могут быть использованы и в других местах.

9. Не бояться расходовать время на подбор правильного имени. Зачастую переименование приводит к полезной
  реструктуризации кода.

## Глава 3. Функции

1. Функции должны быть компактными (в пределах разумного). Например, функция не должна ради компактности сокращаться до
  одного вызова другой функции. При этом, если функция имеет логику разветвления, то все, что она должна делать -
  вызвать другую функцию в соответствующей ветке `if-else`.

2. Функция должна выполнять только одну операцию. Одной операцией можно считать разные действия,
  но **на одном уровне абстракции**. Если из функции можно извлечь другую функцию,
  и это не будет простой переформулировкой реализации, то это значит, что функция выполняет более одной операции.

3. Не смешивать разные уровни абстракции в одной функции.

4. Функции в коде должны быть записаны последовательно по мере понижения уровня абстракции. То есть каждая функция
  вводит последующие, которые имеют меньший уровень абстракции. Такой код легко читаются сверху-вниз.

5. Конструкции типа `switch` или длинные цепочки `if-else` должны встречаться в программе
  однократно для данной сущности и должны скрываться внутри фабрик полиморфных объектов.

6. Если функция принимает на вход аргумент-флаг и в зависимости от его значения выполняет то или иное действие, то лучше
  разбить такую функцию на две отдельных, по названию которых будет понятно, какое именно действие они выполняют.

7. Если функция принимает на вход два аргумента, то они должны быть связаны логически, а порядок их передачи должен быть
  интуитивно понятен. Например, создание точки `new Point(0, 0)`.

8. Избегать побочных эффектов функции. Они приводят к временнЫм привязкам - функция может быть вызвана только
  в определенный момент. Если избежать побочного эффекта не получается, его наличие следует отразить в названии функции.

9. Выходных аргументов стоит избегать. Если функция меняет чье-то состояние, то пусть она меняет состояние
  своего объекта-владельца.

10. Разделять команды и запросы. Функция должна либо что-то делать, либо отвечать на какой-то вопрос,
  но не одновременно. Пример **плохого** паттерна:

```java
public boolean set(String attribute, String value);
...
if (set("username", "Andrey"))
```

В условии `if` не понятно, что именно проверяет `set` - был ли ранее установлен атрибут в такое значение
или успешно ли прошла его новая установка?

## Глава 4. Комментарии

1. Если код получился запутанным, то лучше потратить время на его переписывание, чем на написание поясняющего
  комментария к нему.

2. Название функции или переменной может сообщать то же, что и комментарий. Если какой-то участок кода не понятен,
  его можно вынести в функцию с говорящим названием.

3. Регулярно просматривать и удалять/исправлять неактуальные TODO-комментарии.

4. Не писать избыточные комментарии. Такие комментарии могут просто описывать то же, что говорит сам код, при этом
  не неся никакой дополнительной информации или пояснений.

5. Нет смысла писать Javadoc/Jsdoc комментарии во внутреннем коде, который не предназначен для использования как внешний
  API. Их формализм только отвлекает читателя/писателя, а генерация документации не требуется.

## Глава 5. Форматирование

1. Файл с кодом должен читаться сверху-вниз. Сверху располагаются высокоуровневые концепции. Степень детализации
  увеличивается по мере приближения к концу файла. В самом конце собираются функции и алгоритмы низшего уровня.

2. Вертикальные расстояния улучшают читаемость и восприятие кода. Функции стоит отделять друг от друга пустыми строками,
  а концепции, которые связаны друг с другом должны находиться рядом по вертикали, чтобы для их чтения не нужно было
  перемещаться далеко по файлу.

3. Связанные функции (методы) должны располагаться последовательно. Причем вызываемая функция должна располагаться после
 вызывающей ее.

4. Ограничение строки по количеству символов важно для удобства чтения кода - для чтения коротких строк не приходится
  прокручивать экран по горизонтали. Сейчас оптимальным ограничением на длину строки является 120 символов.

## Глава 6. Объекты и структуры данных

1. Код в процедурном стиле, использующий структуры данных, позволяет легко добавлять новые функции без изменения
  существующих структур данных. Но процедурный код усложняет добавление новых структур данных, потому что
  оно требует изменения всех существующих процедур.

2. Объектно-ориентированный код упрощает добавление новых классов без изменения существующих функций.
  Но объектно-ориентированный код усложняет добавление новых функций, потому что для этого должны измениться все классы.

3. Если в некоторой системе нас прежде всего интересует гибкость в добавлении новых типов данных, то в этой части
  системы предпочтение отдается объектной реализации. В других случаях, когда нужна гибкость расширения поведения,
  в этой части используются типы данных и структуры.

## Глава 7. Обработка ошибок

1. Использовать исключения вместо кодов ошибок. Использование исключений делает код чище, позволяет разделить логику
  обработки ошибки от логики самого алгоритма с помощью конструкций `try-catch`.

2. Передавать в throw подробный контекст (сообщение), по которому было бы понятно, какая операция не удалась
  и почему именно.

3. Определять классы исключений в контексте потребностей вызывающей стороны. Например, если используется библиотека
  с внешним API, которая выбрасывает множество разных исключений, можно создать обертку над ее вызовом, которая будет
  обрабатывать все исключения, а наружу выбрасывать только одно общее, которое имеет смысл для вызывающей стороны.

4. Часто в определенной области кода бывает достаточно одного класса исключения. Информация, передаваемая вместе
  с исключением позволяет различать разные виды ошибок. Разные классы исключений следует использовать только тогда,
  когда необходимо перехватывать одни исключения, разрешая прохождение других типов.

## Глава 8. Границы

1. Прятать использование граничного интерфейса внутри специального класса. Граничный интерфейс - это публичный
  интерфейс другой библиотеки, который используется по всей системе или передается как публичный интерфейс
  нашей библиотеки.

2. При интеграции новой внешней библиотеки можно написать учебные тесты на тот ее функционал, который планируется
  использовать в рамках разрабатываемой программы. Такие тесты позволят сразу познакомиться с API этой библиотеки,
  а также иметь проверку в виде тестов при обновлении этой библиотеки до новых версий.

3. Сводить количество обращений к стороннему коду к минимуму с помощью написания оберток и адаптеров к нему, которые
  в свою очередь уже будут использоваться в коде разрабатываемой программы.

## Глава 9. Модульные тесты

1. Код тестов не менее важен, чем код самого продукта. Тесты надо содержать в такой же чистоте, как и код продукта.

2. Тесты обеспечивают возможность изменения продукта. Любое изменение без тестов может приводить к появлению скрытых
  ошибок. Тесты же сразу покажут такие ошибки при внесении изменений.

3. Выносить из тестов детали реализаций в отдельные функции. Стоит придерживаться паттерна
  `построение - операции - проверка`.

4. Количество директив `assert` в одном тесте должно быть сведено к минимуму.

5. В одном тесте должна проверяться только одна концепция.

6. Еще 5 характеристик тестов:
   1. **Быстрота**. Тесты должны выполняться быстро, чтобы ничто не останавливало от их частого запуска.

   2. **Независимость**. Тесты не должны зависеть друг от друга. Один тест не должен создавать условия для прохождения
       другого теста. Тесты должны без ошибок выполняться в случайном порядке.

   3. **Повторяемость**. Тесты должны давать повторяемые результаты в любой среде.

   4. **Очевидность.** Результатом выполнения теста должен быть логический признак - тест прошел или не прошел.
       При неочевидности результата теста отказы приобретают субъективный характер.

   5. **Своевременность**. Модульные тесты должны писаться _непосредственно перед кодом продукта_.
