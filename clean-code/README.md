# Чистый код. Роберт Мартин

## Глава 1. Чистый код

1. Беспорядок в коде замедляет работу с ним.

2. Программист несет ответственность за донесение до начальства реальных сроков разработки,
  которые учитывают написание правильного чистого кода.

3. Программисты больше читают код, чем пишут его. Чтение старого кода необходимо для написания нового. Поэтому чистота
  кода является очень важным пунктом.

4. Правило бойскаута: оставлять код чище, чем он был до нашего прихода.

## Глава 2. Содержательные имена

1. Имена должны передавать намерения программиста.

2. Не использовать в названии переменной тип данных или структуру данных, в которой хранятся данные.
  Это может вводить в заблуждение и вызывать ненужные ассоциации. Структура данных может поменяться в дальнейшем.

3. Записывать различающиеся имена так, чтобы читатель кода понимал, какой смысл заложен в этих различиях. Например,
  `Product` и `ProductInfo`, `money` и `moneyAmount` - плохие отличия в именах.

4. Имена должны удобно читаться как обычные слова.

5. Использовать для перегрузок конструкторов статические методы-фабрики. Соответствующие конструкторы
  можно объявлять приватными. Например:

```java
// Bad
new Complex(23.0)

// Good
Complex.FromRealNumber(23.0)
```

6. Использовать одно слово для представления одной абстрактной концепции или сущности. Например, `get`, `fetch`,
  `retreive` называются по-разному, но в сущности выполняют одно и то же действие, и по названиям не понятно,
  в чем их отличия, если они есть. Но если методы выполняют семантически разные вещи, то и названия должны отличаться.

7. Добавлять именам содержательный контекст. Например, если несколько переменных являются частью какой-то сущности,
  то их следует объединить в объект или пространство имен. Так будет понятен их контекст.

8. Не добавлять именам избыточный контекст. Например, нет смысла добавлять префикс класса ко всем полям этого класса -
  они и так уже находятся в его контексте. Именам классов так же не следует давать дополнительный контекст, если они
  потенциально могут быть использованы и в других местах.

9. Не бояться расходовать время на подбор правильного имени. Зачастую переименование приводит к полезной
  реструктуризации кода.

## Глава 3. Функции

1. Функции должны быть компактными (в пределах разумного). Например, функция не должна ради компактности сокращаться до
  одного вызова другой функции. При этом, если функция имеет логику разветвления, то все, что она должна делать -
  вызвать другую функцию в соответствующей ветке `if-else`.

2. Функция должна выполнять только одну операцию. Одной операцией можно считать разные действия,
  но **на одном уровне абстракции**. Если из функции можно извлечь другую функцию,
  и это не будет простой переформулировкой реализации, то это значит, что функция выполняет более одной операции.

3. Не смешивать разные уровни абстракции в одной функции.

4. Функции в коде должны быть записаны последовательно по мере понижения уровня абстракции. То есть каждая функция
  вводит последующие, которые имеют меньший уровень абстракции. Такой код легко читаются сверху-вниз.

5. Конструкции типа `switch` или длинные цепочки `if-else` должны встречаться в программе
  однократно для данной сущности и должны скрываться внутри фабрик полиморфных объектов.

6. Если функция принимает на вход аргумент-флаг и в зависимости от его значения выполняет то или иное действие, то лучше
  разбить такую функцию на две отдельных, по названию которых будет понятно, какое именно действие они выполняют.

7. Если функция принимает на вход два аргумента, то они должны быть связаны логически, а порядок их передачи должен быть
  интуитивно понятен. Например, создание точки `new Point(0, 0)`.

8. Избегать побочных эффектов функции. Они приводят к временнЫм привязкам - функция может быть вызвана только
  в определенный момент. Если избежать побочного эффекта не получается, его наличие следует отразить в названии функции.

9. Выходных аргументов стоит избегать. Если функция меняет чье-то состояние, то пусть она меняет состояние
  своего объекта-владельца.

10. Разделять команды и запросы. Функция должна либо что-то делать, либо отвечать на какой-то вопрос,
  но не одновременно. Пример **плохого** паттерна:

```java
public boolean set(String attribute, String value);
...
if (set("username", "Andrey"))
```

В условии `if` не понятно, что именно проверяет `set` - был ли ранее установлен атрибут в такое значение
или успешно ли прошла его новая установка?
